// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1982.Robot2017.commands;
import org.usfirst.frc1982.Robot2017.Robot;
import org.usfirst.frc1982.Robot2017.RobotMap;

import edu.wpi.first.wpilibj.RobotDrive.MotorType;
import edu.wpi.first.wpilibj.command.Command;

/**
 *
 */
public class _DriveEnable extends Command {
	
	private double maxSpeed;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public _DriveEnable() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drive);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        maxSpeed = 1.56 * 1000.0 / 20.0;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
//    	RobotMap.frontLeftPID.setOutputRange(-1.0, 1.0);
//    	RobotMap.frontRightPID.setOutputRange(-1.0, 1.0);
//    	RobotMap.backLeftPID.setOutputRange(-1.0, 1.0);
//    	RobotMap.backRightPID.setOutputRange(-1.0, 1.0);
//    	
//    	RobotMap.frontLeftPID.enable();
//    	RobotMap.frontRightPID.enable();
//    	RobotMap.backLeftPID.enable();
//    	RobotMap.backRightPID.enable();
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
//    	RobotMap.driveDriveTrain.mecanumDrive_Cartesian(Robot.oi.driverJoystick.getX(), Robot.oi.driverJoystick.getY(), Robot.oi.driverJoystick.getTwist(), 0);
    	
    	
//    	/////translate joystick input to mecanum output between -1, and 1 for each wheel (depending on joystick X, Y, and Twist)
//        double xIn = Robot.oi.driverJoystick.getX();
//    	
//        double yIn = Robot.oi.driverJoystick.getY();
//        // Negate y for the joystick.
//        yIn = -yIn;
//        
//        double rotation = Robot.oi.driverJoystick.getTwist()/2;
//        
//        
//        //////use for field absolute driving
////        // Compenstate for gyro angle.
////        double[] rotated = rotateVector(xIn, yIn, gyroAngle);
////        xIn = rotated[0];
////        yIn = rotated[1];
//        
//        
////        /////outputs between -1 and 1 (full power forwards and backwards) based on joystick
////        double frontLeft = xIn + yIn + rotation;
////        double frontRight = -xIn + yIn - rotation;
////        double rearLeft = -xIn + yIn + rotation;
////        double rearRight = xIn + yIn - rotation;
//        
//        
//        double[] wheelSpeeds = new double[4];
//        wheelSpeeds[0] = xIn + yIn + rotation; //front left
//        wheelSpeeds[1] = -xIn + yIn - rotation; //front right
//        wheelSpeeds[2] = -xIn + yIn + rotation; //rear left
//        wheelSpeeds[3] = xIn + yIn - rotation; //rear right
//        normalize(wheelSpeeds);
        
    	//TODO: switch this to the drivetrain mecanum drive (for testing if the motors actually work right)
//    	Robot.driver.setMotorsBasedOnJoystick();
    	
    	RobotMap.driveDriveTrain.mecanumDrive_Cartesian(Robot.oi.driverJoystick.getX(), Robot.oi.driverJoystick.getY(), Robot.oi.driverJoystick.getTwist(), 0.0);
//    	RobotMap.driveDriveTrain.mecanumDrive_Cartesian(0.0, .25, 0.0, 0.0);
//    	Robot.driver.setMotorsMecanum(0.0, .25, 0.0);
    	
//        RobotMap.frontLeftPID.setSetpoint(wheelSpeeds[0] * maxSpeed);
//        RobotMap.frontRightPID.setSetpoint(wheelSpeeds[1] * maxSpeed);
//        RobotMap.backLeftPID.setSetpoint(wheelSpeeds[2] * maxSpeed);
//        RobotMap.backRightPID.setSetpoint(wheelSpeeds[3] * maxSpeed);
        
    }
    
    private void normalize(double[] wheelSpeeds) {
        double maxMagnitude = Math.abs(wheelSpeeds[0]);
        for (int i = 1; i < 4; i++) {
          double temp = Math.abs(wheelSpeeds[i]);
          if (maxMagnitude < temp) {
            maxMagnitude = temp;
          }
        }
        if (maxMagnitude > 1.0) {
          for (int i = 0; i < 4; i++) {
            wheelSpeeds[i] = wheelSpeeds[i] / maxMagnitude;
          }
        }
      }
    
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
//    	RobotMap.frontLeftPID.disable();
//    	RobotMap.frontRightPID.disable();
//    	RobotMap.backLeftPID.disable();
//    	RobotMap.backRightPID.disable();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
//    	RobotMap.frontLeftPID.disable();
//    	RobotMap.frontRightPID.disable();
//    	RobotMap.backLeftPID.disable();
//    	RobotMap.backRightPID.disable();
    }
}
