// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1982.Robot2017.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1982.Robot2017.Robot;
import org.usfirst.frc1982.Robot2017.RobotMap;

/**
 *
 */
public class _DriveEnableRaw extends Command {
	
	private double multFL = .975;
	private double multFR = .975;
	private double multBL = 1.125;
	private double multBR = .7;
	
	private double multFLB = 1.0;
	private double multFRB = 1.0;
	private double multBLB = 1.1;
	private double multBRB = .5;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public _DriveEnableRaw() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drive);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
//    	oldTime = System.currentTimeMillis();
//    	oldDist = 0.0;
    	RobotMap.driveEncoderFrontLeft.reset();
    	
    	SmartDashboard.putNumber("Multiplier for Front Left: ", multFL);
    	SmartDashboard.putNumber("Multiplier for Front Right: ", multFR);
    	SmartDashboard.putNumber("Multiplier for Back Left: ", multBL);
    	SmartDashboard.putNumber("Multiplier for Back Right: ", multBR);
    	
    	SmartDashboard.putNumber("Multiplier for Front Left Back: ", multFLB);
    	SmartDashboard.putNumber("Multiplier for Front Right Back: ", multFRB);
    	SmartDashboard.putNumber("Multiplier for Back Left Back: ", multBLB);
    	SmartDashboard.putNumber("Multiplier for Back Right Back: ", multBRB);
    }
    
//    private long oldTime;
//    private double oldDist;
    
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
//    	
    	multFL = SmartDashboard.getNumber("Multiplier for Front Left: ", multFL);
    	multFR = SmartDashboard.getNumber("Multiplier for Front Right: ", multFR);
    	multBL = SmartDashboard.getNumber("Multiplier for Back Left: ", multBL);
    	multBR = SmartDashboard.getNumber("Multiplier for Back Right: ", multBR);
    	
    	multFLB = SmartDashboard.getNumber("Multiplier for Front Left Back: ", multFLB);
    	multFRB = SmartDashboard.getNumber("Multiplier for Front Right Back: ", multFRB);
    	multBLB = SmartDashboard.getNumber("Multiplier for Back Left Back: ", multBLB);
    	multBRB = SmartDashboard.getNumber("Multiplier for Back Right Back: ", multBRB);
    	
    	
//    	RobotMap.driveDriveTrain.mecanumDrive_Cartesian(Robot.oi.driverJoystick.getX(), Robot.oi.driverJoystick.getY(), Robot.oi.driverJoystick.getTwist()/2, 0);
    	
    	
    	double xIn = Robot.oi.driverJoystick.getX();
    	
        double yIn = Robot.oi.driverJoystick.getY();
//    	double yIn = -.15;
        // Negate y for the joystick.
        yIn = -yIn;
        
        double rotation = Robot.oi.driverJoystick.getTwist()/2;
        
//        ////use for field absolute driving
//        // Compenstate for gyro angle.
//        double[] rotated = rotateVector(xIn, yIn, gyroAngle);
//        xIn = rotated[0];
//        yIn = rotated[1];
        
        double[] wheelSpeeds = new double[4];
        wheelSpeeds[0] = (xIn + yIn + rotation);// * multFL; //front left
        wheelSpeeds[1] = (-xIn + yIn - rotation);// * multFR; //front right
        wheelSpeeds[2] = (-xIn + yIn + rotation);// * multBL; //rear left
        wheelSpeeds[3] = (xIn + yIn - rotation);// * multBR; //rear right
        normalize(wheelSpeeds);
    	
        if (wheelSpeeds[0] > 0) RobotMap.driveFrontLeft.set(wheelSpeeds[0] * multFL);
        else RobotMap.driveFrontLeft.set(wheelSpeeds[0] * multFLB);
        
        if (wheelSpeeds[1] > 0) RobotMap.driveFrontRight.set(wheelSpeeds[1] * multFR);
        else RobotMap.driveFrontRight.set(wheelSpeeds[1] * multFRB);
        
        if (wheelSpeeds[2] > 0) RobotMap.driveBackLeft.set(wheelSpeeds[2] * multBL);
        else RobotMap.driveBackLeft.set(wheelSpeeds[2] * multBLB);
        
        if (wheelSpeeds[3] > 0) RobotMap.driveBackRight.set(wheelSpeeds[3] * multBR);
        else RobotMap.driveBackRight.set(wheelSpeeds[3] * multBRB);
        
//        RobotMap.driveFrontLeft.set(wheelSpeeds[0]);
//        RobotMap.driveFrontRight.set(wheelSpeeds[1]);
//        RobotMap.driveBackLeft.set(wheelSpeeds[2]);
//        RobotMap.driveBackRight.set(wheelSpeeds[3]);
        
        System.out.println("FL: " + RobotMap.driveEncoderFrontLeft.getRate() + " FR: " + RobotMap.driveEncoderFrontRight.getRate() + " BL: " + RobotMap.driveEncoderBackLeft.getRate() + " BR: " + RobotMap.driveEncoderBackRight.getRate());
		
        
        
        
    	
//    	if (Robot.oi.driverJoystick.getY() > .95) {
//    		double curDist = RobotMap.driveEncoderFrontLeft.getDistance();
//    		long currentTime = System.currentTimeMillis();
    		
//    		double difDist = curDist - oldDist;
//    		long passed = currentTime - oldTime;
    		
//    		System.out.println(Robot.oi.driverJoystick.getY());
    		
//    		System.out.println("Encoder Front Left Distance: " + RobotMap.driveEncoderFrontLeft.getDistance());
//    		System.out.println("Encoder Front Right Distance(): " + RobotMap.driveEncoderFrontRight.getDistance());
//    		System.out.println("Encoder Back Left Distance(): " + RobotMap.driveEncoderBackLeft.getDistance());
//    		System.out.println("Encoder Back Right Distance(): " + RobotMap.driveEncoderBackRight.getDistance());
    		
//    		oldDist = curDist;

//    		System.out.println("Time since: " + passed);
//    		oldTime = currentTime;
//    	} else {
//    		RobotMap.driveEncoderFrontLeft.reset();
//    	}
    }
    
    private void normalize(double[] wheelSpeeds) {
        double maxMagnitude = Math.abs(wheelSpeeds[0]);
        for (int i = 1; i < 4; i++) {
          double temp = Math.abs(wheelSpeeds[i]);
          if (maxMagnitude < temp) {
            maxMagnitude = temp;
          }
        }
        if (maxMagnitude > 1.0) {
          for (int i = 0; i < 4; i++) {
            wheelSpeeds[i] = wheelSpeeds[i] / maxMagnitude;
          }
        }
      }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
